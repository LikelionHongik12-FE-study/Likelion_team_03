## Section 10 ì¡°ê±´ë¶€ íƒ€ì…

### ì¡°ê±´ë¶€ íƒ€ì… ì†Œê°œ Conditional Types

- ì¡°ê±´ë¶€ íƒ€ì…

  1. ?ë¥¼ ì´ìš©í•œ ì‚¼í•­ ì—°ì‚°ìë¥¼ í†µí•´ ì¡°ê±´ì— ë”°ë¼ íƒ€ì…ì„ ê²°ì •í•˜ëŠ” ë¬¸ë²•

     ```tsx
     //ì¡°ê±´ë¶€ íƒ€ì…

     type A = number extends string ? string : number;
     // íƒ€ì… A: number íƒ€ì…ì´ string íƒ€ì…ì„ í™•ì¥í•˜ëŠ” íƒ€ì…ì´ëƒ => ê±°ì§“ => number

     type ObjA = {
       a: number;
     };

     type ObjB = {
       a: number;
       b: number;
     };

     type B = ObjB extends ObjA ? number : string; // ì¡°ê±´ ì°¸ => number
     ```

  1. ì œë„¤ë¦­ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ ìœ„ë ¥ Good

     ```tsx
     //ì œë„¤ë¦­ê³¼ ì¡°ê±´ë¶€ íƒ€ì…

     type StringNumberSwitch<T> = T extends number ? string : number;
     //íƒ€ì… ë³€ìˆ˜ì— numberê°€ ë“¤ì–´ì˜¤ë©´ ì¡°ê±´ ì°¸, stringì´ ë“¤ì–´ì˜¤ë©´ ì¡°ê±´ ê±°ì§“

     let varA: StringNumberSwitch<number>; //string
     let varB: StringNumberSwitch<string>; //number
     //íƒ€ì…ì„ ê°€ë³€ì ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ì„œë„ ë…¼ë¦¬ íë¦„ì— ë”°ë¼ íƒ€ì…ì„ ë°”ê¿”ì¤„ ìˆ˜ ìˆë‹¤.
     ```

  1. í•¨ìˆ˜ì— ì‚¬ìš©

     ```tsx
     function removeSpaces(text: string) {
       return text.replaceAll(" ", "");
     } //replaceAll: ì²«ë²ˆì¨° ì¸ìˆ˜ì— í•´ë‹¹í•˜ëŠ” ë¬¸ìì—´ì„ ëª¨ë‘ ì°¾ì•„ ë‘ë²ˆì§¸ ì¸ìˆ˜ë¡œ ë°”ê¿”ì£¼ëŠ” ë©”ì„œë“œ

     let result = removeSpaces("hi im winterlood");
     result.toUpperCase();
     ```

     ```tsx
     function removeSpaces(text: string | undefined | null) {
       if (typeof text === "string") {
         // íƒ€ì…ì¢íˆê¸° ì‚¬ìš©
         return text.replaceAll(" ", ""); //string ë©”ì„œë“œ ì‚¬ìš© x -> text ì˜¤ë¥˜ ë°œìƒ
       } else {
         return undefined;
       }
     }

     let result = removeSpaces("hi im winterlood");
     result.toUpperCase(); //ê·¸ëŸ¬ë‚˜ resultì—ì„œ ì˜¤ë¥˜ ë°œìƒ
     ```

     ```tsx
     //ë”°ë¼ì„œ ì œë„¤ë¦­ ì´ìš© + any íƒ€ì… ë‹¨ì–¸ (0 as any ì´ëŸ°ì‹ìœ¼ë¡œ ì¨ë„ ê²€ì‚¬ê°€ ì•ˆëœë‹¤ëŠ” ë¬¸ì œ)
     function removeSpaces<T>(text: T) : T extends string ? string : undefined{
     	if (typeof text === 'string'){
     		return text.replaceAll(" ", "") as any; //ì¡°ê±´ë¶€íƒ€ì…ì˜ ê²°ê³¼ë¥¼ ëª°ë¼ì„œ ì˜¤ë¥˜ => any íƒ€ì… ë‹¨ì–¸ í•„ìš”
     	} else {
     		return undefined as any;
     	}
     }

     let result = removeSpaces("hi im winterlood");
     result.toUpperCase();

     let result2 = removeSpaces(undefined);

     ---------------------------------------------------------
     //ì œë„¤ë¦­ + í•¨ìˆ˜ ì˜¤ë²„ë¡œë“œ ì‹œê·¸ë‹ˆì²˜ ì‚¬ìš©
     function removeSpaces<T>(text: T) : T extends string ? string : undefined
     function removeSpaces(text: any) {
     	if (typeof text === 'string'){
     		return text.replaceAll(" ", "");
     	} else {
     		return undefined;
     	}
     }

     let result = removeSpaces("hi im winterlood");
     result.toUpperCase();

     let result2 = removeSpaces(undefined);
     ```

### ë¶„ì‚°ì ì¸ ì¡°ê±´ë¶€ íƒ€ì… Distributive Conditional Types

```tsx
//ë¶„ì‚°ì ì¸ ì¡°ê±´ë¶€ íƒ€ì…: ì¡°ê±´ë¶€ íƒ€ì…ì„ unionê³¼ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ, ì¡°ê±´ë¶€ íƒ€ì…ì´ ë¶„ì‚°ì ìœ¼ë¡œ ë™ì‘í•˜ëŠ” ì—…ê·¸ë ˆì´ë“œ ëœ ë¬¸ë²•

type StringNumberSwitch<T> = T extends number ? string : number;

let a: StringNumberSwitch<number>;
let b: StringNumberSwitch<string>;

//ì¡°ê±´ë¶€ íƒ€ì…ì— íƒ€ì… ë³€ìˆ˜ë¥¼ Unionìœ¼ë¡œ í• ë‹¹í•˜ë©´, ë¶„ì‚°ì ì¸ ì¡°ê±´ë¶€ íƒ€ì…ìœ¼ë¡œ upgradeë¨
let c: StringNumberSwitch<number | string>; //let c : string | number

// í•œ ë²ˆì€ number, í•œë²ˆì€ stringìœ¼ë¡œ ë¶„ë¦¬ë˜ì–´ ë“¤ì–´ì˜´
// StringNumberSwitch<number> -> string
// StringNumberSwitch<string> -> number

let d: StringNumberSwitch<boolean | number | string>;
// 1ë‹¨ê³„
// StringNumberSwitch<boolean> |
// StringNumberSwitch<number> |
// StringNumberSwitch<string>

// 2ë‹¨ê³„
// number |
// string |
// number

// ê²°ê³¼
// number | string
```

```tsx
//ì‹¤ìš©ì ì¸ ì˜ˆì œ

type Exclude<T, U> = T extends U ? never : T; //Uì— í•´ë‹¹í•˜ëŠ” íƒ€ì… ì œê±°
type A = Exclude<number | string | boolean, string>;

// 1ë‹¨ê³„
// Exclude<number, string> |
// Exclude<string, string> |
// Exclude<boolean, string>

// 2ë‹¨ê³„
// number |
// never |
// boolean

// ê²°ê³¼
// number | never | boolean ì¸ë° ê²°ê³¼ì— neverê°€ í¬í•¨ë˜ì–´ìˆìœ¼ë©´ ì‚¬ë¼ì§
// number | boolean => íŠ¹ì • íƒ€ì…ì„ ì œê±°í•˜ëŠ” í•¨ìˆ˜ ë§Œë“¤ê¸° ê°€ëŠ¥

type Extract<T, U> = T extends U ? T : never; //Uì— í•´ë‹¹í•˜ëŠ” íƒ€ì… ì¶”ì¶œ
type B = Extract<number | string | boolean, string>; //string

// 1ë‹¨ê³„
// Extract<number, string> |
// Extract<string, string> |
// Extract<boolean, string>

// 2ë‹¨ê³„
// never |
// string |
// never

// ê²°ê³¼
// string

//ë¶„ì‚° ë°©ì§€í•˜ëŠ” ë°©ë²• ì˜ˆì‹œ: [T] extends [number] ? string: number;
```

### infer - ì¡°ê±´ë¶€ íƒ€ì… ë‚´ì—ì„œ íƒ€ì… ì¶”ë¡ í•˜ê¸°

- inference ì¶”ë¡ 

  ```tsx
  //infer: ì¡°ê±´ë¶€ íƒ€ì… ë‚´ì—ì„œ íŠ¹ì • íƒ€ì…ë§Œ ì¶”ë¡ í•´ì˜¬ ìˆ˜ ìˆëŠ” ê¸°ëŠ¥

  type FuncA = () => string;
  type FuncB = () => number;
  type ReturnType<T> = T extends () => string ? string : never;

  type A = ReturnType<FuncA>; //string
  type B = ReturnType<FuncB>; //never
  ```

  ```tsx
  type FuncA = () => string;
  type FuncB = () => number;
  type ReturnType<T> = T extends () => infer R ? R : never;

  type A = ReturnType<FuncA>; //string, ì¡°ê±´ì´ ì°¸ì´ ë˜ë„ë¡ Rì„ string íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ 
  type B = ReturnType<FuncB>; //number, ì¡°ê±´ì´ ì°¸ì´ ë˜ë„ë¡ Rì„ number íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ 
  type C = ReturnType<number>; //never, ì¶”ë¡ ì´ ë¶ˆê°€ -> ì¡°ê±´ì´ ê±°ì§“ì´ ë¨
  ```

  ```tsx
  //ì˜ˆì œ

  type PromiseUnpack<T> = T extends Promise<infer R> ? R : never;
  //1. TëŠ” í”„ë¡œë¯¸ìŠ¤ íƒ€ì…ì´ì–´ì•¼ í•œë‹¤.
  //2. í”„ë¡œë¯¸ìŠ¤ íƒ€ì…ì˜ ê²°ê³¼ê°’ íƒ€ì…ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤.

  type PromiseA = PromiseUnpack<Promise<number>>;
  //number

  type PromiseB = PromiseUnpack<Promise<string>>;
  //string
  ```

## Section11 ìœ í‹¸ë¦¬í‹° íƒ€ì…

### ìœ í‹¸ë¦¬í‹° íƒ€ì… ì†Œê°œ Utility Types

<aside>
ğŸ’¡ **ìœ í‹¸ë¦¬í‹° íƒ€ì…:** ì œë„¤ë¦­, ë§µë“œ íƒ€ì…, ì¡°ê±´ë¶€ íƒ€ì… ë“±ì˜ íƒ€ì… ì¡°ì‘ ê¸°ëŠ¥ì„ ì´ìš©í•´ ì‹¤ë¬´ì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” íƒ€ì…ì„ ë¯¸ë¦¬ ë§Œë“¤ì–´ ë†“ì€ ê²ƒ

```tsx
//ì˜ˆì‹œ: Readonly<T>
interface Person {
  name: string;
  age: number;
}

const person: Readonly<Person> = {
  name: "ì´ì •í™˜",
  age: 27,
};

person.name = ""; //ì˜¤ë¥˜ ë°œìƒ
```

```tsx
//ì˜ˆì‹œ: Partial<T>
interface Person {
  name: string;
  age: number;
}

const person: Partial<Person> = {
  name: "ì´ì •í™˜",
}; //ëª¨ë“  í”„ë¡œí¼í‹°ë¥¼ ì„ íƒì  í”„ë¡œí¼í‹°ë¡œ ë³€ê²½
```

</aside>

- ë§µë“œ íƒ€ì… ê¸°ë°˜:
  Partial<T>, Required<T>, Readonly<T>, Pick<T,K>, Omit<T,K>, Record<K,V>
- ì¡°ê±´ë¶€ íƒ€ì… ê¸°ë°˜:
  Exclude<T, U>, Extract<T, U>, ReturnType<T>

### ë§µë“œ íƒ€ì… ê¸°ë°˜ì˜ ìœ í‹¸ë¦¬í‹° íƒ€ì… 1 - Partial, Required, Readonly

```tsx
// Partial<T>: ë¶€ë¶„ì ì¸, ì¼ë¶€ë¶„ì˜
// íŠ¹ì • ê°ì²´ íƒ€ì…ì˜ ëª¨ë“  í”„ë¡œí¼í‹°ë¥¼ ì„ íƒì  í”„ë¡œí¼í‹°ë¡œ ë°”ê¿”ì£¼ëŠ” íƒ€ì…

interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

type Partial<T> = {
  [key in keyof T]?: T[key];
};
//keyof í‚¤ì›Œë“œ: íŠ¹ì • ê°ì²´ íƒ€ì…ìœ¼ë¡œë¶€í„° ëª¨ë“  í‚¤ë¥¼ union íƒ€ì…ìœ¼ë¡œ ì¶”ì¶œí•˜ëŠ” ì—°ì‚°ì
//in í‚¤ì›Œë“œ: ë§µë“œ íƒ€ì…ì—ì„œ ì œê³µí•˜ëŠ” ì—°ì‚°ì
//key in keyof T: ì™¼ìª½ì˜ keyê°€ ì˜¤ë¥¸ìª½ì˜ union íƒ€ì…ì— í•˜ë‚˜ì”© ë§µí•‘ë¨
//T[key]: ì¸ë±ìŠ¤íŠ¸ ì•¡ì„¸ìŠ¤ íƒ€ì… - íŠ¹ì • ê°ì²´ë‚˜ ë°°ì—´ë¡œë¶€í„° íŠ¹ì • í”„ë¡œí¼í‹°ì˜ íƒ€ì…ì„ ì¶”ì¶œí•˜ëŠ” íƒ€ì…

const draft: Partial<Post> = {
  // íƒ€ì… ë³€ìˆ˜ë¡œ ì „ë‹¬í•œ post íƒ€ì…ì˜ ëª¨ë“  í”„ë¡œí¼í‹°ë¥¼ ì„ íƒì  í”„ë¡œí¼í‹°ë¡œ ë³€ê²½
  title: "ì œëª© ë‚˜ì¤‘ì— ì§“ì",
  content: "ì´ˆì•ˆ...",
};
```

```tsx
// Required<T>: í•„ìˆ˜ì˜, í•„ìˆ˜ì ì¸
// íŠ¹ì • ê°ì²´ íƒ€ì…ì˜ ëª¨ë“  í”„ë¡œí¼í‹°ë¥¼ í•„ìˆ˜ í”„ë¡œí¼í‹°ë¡œ ë°”ê¿”ì£¼ëŠ” íƒ€ì…

type Required<T> = {
  [key in keyof T]-?: T[key];
};

const withThumbnailPost: Required<Post> = {
  title: "í•œì… íƒ€ìŠ¤ í›„ê¸°",
  tags: ["ts"],
  content: "",
  thumbnailURL: "https://...",
};
```

```tsx
// Readonly<T>: ì½ê¸°ì „ìš© ìˆ˜ì •ë¶ˆê°€
// íŠ¹ì • ê°ì²´ íƒ€ì…ì—ì„œ ëª¨ë“  í”„ë¡œí¼í‹°ë¥¼ ì½ê¸° ì „ìš© í”„ë¡œí¼í‹°ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” íƒ€ì…

type Readonly<T> = {
  readonly [key in keyof T]: T[key];
};

const readonlyPost: Readonly<Post> = {
  title: "ë³´í˜¸ëœ ê²Œì‹œê¸€ì…ë‹ˆë‹¤.",
  tags: [],
  content: "",
};

readonlyPost.content = ""; //ì˜¤ë¥˜
```

### ë§µë“œ íƒ€ì… ê¸°ë°˜ì˜ ìœ í‹¸ë¦¬í‹° íƒ€ì… 2 - Pick, Omit, Record

```tsx
// Pick<T, K>: ë½‘ë‹¤, ê³ ë¥´ë‹¤
// ê°ì²´ íƒ€ì…ìœ¼ë¡œë¶€í„° íŠ¹ì • í”„ë¡œí¼í‹°ë§Œ ë”± ê³¨ë¼ë‚´ëŠ” íƒ€ì…

interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

type Pick<T, K extends keyof T> = {
  // K extends 'title' | 'tags' | 'content' | 'thumbnailURL'
  // 'title' | 'content' extends 'title' | 'tags' | 'content' | 'thumbnailURL' -> ì°¸
  [key in K]: T[key];
};

const legacyPost: Pick<Post, "title" | "content"> = {
  title: "ì˜›ë‚  ê¸€",
  content: "ì˜›ë‚  ì»¨í…ì¸ ",
};
```

```tsx
// Omit<T, K>: ìƒëµí•˜ë‹¤, ë¹¼ë‹¤
// ê°ì²´ íƒ€ì…ìœ¼ë¡œë¶€í„° íŠ¹ì • í”„ë¡œí¼í‹°ë¥¼ ì œê±°í•˜ëŠ” íƒ€ì…

type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
// T = Post, K = 'title'
// Pick<Post, Exclude<keyof Post, 'title'>>
// Pick<Post, Exclude<'title' | 'tags' | 'content' | 'thumbnailURL', 'title'>>
// Pick<Post, 'content' | 'tags' | 'thumbnailURL'>

const noTitlePost: Omit<Post, "title"> = {
  //title í”„ë¡œí¼í‹°ë§Œ ì œê±°í•¨
  content: "",
  tags: [],
  thumbnailURL: "",
};
```

```tsx
// Record<K, V>

type ThumbnailLegacy = {
  large: {
    url: string;
  };
  medium: {
    url: string;
  };
  small: {
    url: string;
  };
  watch: {
    url: string;
  };
};

type Record<K extends keyof any, V> = {
  [key in K]: V;
};

type Thumbnail = Record<
  "large" | "medium" | "small" | "watch",
  { url: string; size: number }
>;
```

### ì¡°ê±´ë¶€ íƒ€ì… ê¸°ë°˜ì˜ ìœ í‹¸ë¦¬í‹° íƒ€ì… - Exclude, Extract, ReturnType

```tsx
//Exclude<T, U>: ì œì™¸í•˜ë‹¤, ì¶”ë°©í•˜ë‹¤
//Tì—ì„œ Uë¥¼ ì œê±°í•˜ëŠ” íƒ€ì…

type Exclude<T, U> = T extends U ? never : T;
//1ë‹¨ê³„
//Exclude <string, boolean> |
//Exclude <boolean, boolean>

//2ë‹¨ê³„
//string |
//never

//ìµœì¢…ì ìœ¼ë¡œëŠ”
//string

type A = Exclude<string | boolean, boolean>;
```

```tsx
//Extract<T, U>: Tì—ì„œ Uë¥¼ ì¶”ì¶œí•˜ëŠ” íƒ€ì…

type Extract<T, U> = T extends U ? T : never;
type B = Extract<string | boolean, boolean>;
```

```tsx
//ReturnType: í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ íƒ€ì…ì„ ì¶”ì¶œí•˜ëŠ” íƒ€ì…

type ReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : never;

function funcA() {
  return "hello";
}

function funcB() {
  return 10;
}

type ReturnA = ReturnType<typeof funcA>; //string
type ReturnB = ReturnType<typeof funcB>; //number
```

## Section 12 ë¦¬ì•¡íŠ¸ì™€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

### íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì™€ ë¦¬ì•¡íŠ¸ ì‹œì‘í•˜ê¸°

```tsx
npx create-react-app .
npm i @types/node @types/react @types/react-dom @types/jest
// -> Definitely Types
```

```tsx
//tsconfig.json
{
	"compilerOptions": {
		"target": "ES5",
		"module": "CommonJS",
		"strict": true,
		"allowJs": true,
		"esModuleInterop": true,
		"jsx": "react-jsx"
	},
	"include": ["src"]
}
```

```tsx
//index.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

```tsx
//App.tsx
import "./App.css";

function App() {
  return <div className="App"></div>;
}

export default App;
```

### ìƒíƒœê´€ë¦¬ì™€ Props 1

```tsx
//App.tsx
import { useState, useRef, useEffect } from "react";
import "./App.css";
import { Todo } from "./types";

function App() {
  const [todos, setTodos] = useState<Todo[]>([]);

  // useState()ë¼ë©´ undefinedë¡œ ì¶”ë¡ ë¨. tsxì—ì„œëŠ” ì´ëŸ°ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ì§€ ë§ì!
  // const [text, setText] = useState<string>(); -> string | undefined
  const idRef = useRef(0); //React.MutableRefObject<number>

  const onClickAdd = (text: string) => {
    setTodos([
      ...todos,
      {
        id: idRef.current++,
        content: text,
      },
    ]);
  };
  const onClickDelete = (id: number) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  };

  useEffect(() => {
    console.log(todos);
  }, [todos]);

  return (
    <div className="App">
      <h1>Todo</h1>
      <Editor onClickAdd={onClickAdd} />
      <div>
        {todos.map((todo) => (
          <TodoItem key={todo.id} {...todo} onClickDelete={onClickDelete} />
        ))}
      </div>
    </div>
  );
}

export default App;
```

```tsx
//components/Editor.tsx

import { useState } from "react";

export default function Editor(props: Props) {
  const [text, setText] = useState(""); //string type, ì œë„¤ë¦­ í•¨ìˆ˜

  const onChangeInput = (e: React.ChangeEvent<HTMlInputElement>) => {
    setText(e.target.value);
  };

  const onClickButton = () => {
    props.onClickAdd(text);
    setText("");
  };

  return (
    <div>
      <input value={text} onChange={onChangeInput} />
      <button onClick={onClickButton}>ì¶”ê°€</button>
    </div>
  );
}
```

### ìƒíƒœê´€ë¦¬ì™€ Props 2

```tsx
//App.tsx
import { useState, useRef, useEffect, useReducer } from "react";
import "./App.css";
import { Todo } from "./types";

type Action =
  | {
      type: "CREATE";
      data: {
        id: number;
        content: string;
      };
    }
  | { type: "DELETE"; id: number };

function reducer(state: Todo[], action: Action) {
  switch (action.type) {
    case "CREATE": {
      return [...state, action.data];
    }
    case "DELETE": {
      return state.filter((it) => it.id !== action.id);
    }
  }
}

function App() {
  const [todos, dispatch] = useReducer([]);
  //useReducer ë©”ì„œë“œ ì‚¬ìš© (2ê°œì˜ ì¸ìˆ˜ë¥¼ ë°›ìŒ)
  const idRef = useRef(0); //React.MutableRefObject<number>

  const onClickAdd = (text: string) => {
    dispatch({
      type: "CREATE",
      data: {
        id: idRef.current++,
        content: text,
      },
    });
  };

  const onClickDelete = (id: number) => {
    dispatch({
      type: "DELETE",
      id: id,
    });
  };

  useEffect(() => {
    console.log(todos);
  }, [todos]);

  return (
    <div className="App">
      <h1>Todo</h1>
      <Editor onClickAdd={onClickAdd} />
      <div>
        {todos.map((todo) => (
          <TodoItem key={todo.id} {...todo} onClickDelete={onClickDelete} />
        ))}
      </div>
    </div>
  );
}

export default App;
```

```tsx
//components/TodoItem.tsx

import { Todo } from "../types";

//ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” íƒ€ì… ìœ ì§€í•´ì•¼í•  ë• ë³„ë„ì˜ tsx íŒŒì¼ ë§Œë“¤ê¸°
interface Props extends Todo {
  onClickDelete: (id: number) => void;
}

export default function TodoItem(props: Props) {
  const onClickButton = () => {
    props.onClickDelete(props.id);
  };

  return (
    <div>
      {props.id}ë²ˆ: {props.content}
      <button onClick={onClickButton}>ì‚­ì œ</button>
    </div>
  );
}
```

```tsx
//types.ts

export interface Todo {
  id: number;
  content: string;
}
```

### Context API

```tsx
//App.tsx
import React, { useState, useRef, useEffect, useReducer } from "react";
import "./App.css";
import { Todo } from "./types";

type Action =
  | {
      type: "CREATE";
      data: {
        id: number;
        content: string;
      };
    }
  | { type: "DELETE"; id: number };

function reducer(state: Todo[], action: Action) {
  switch (action.type) {
    case "CREATE": {
      return [...state, action.data];
    }
    case "DELETE": {
      return state.filter((it) => it.id !== action.id);
    }
  }
}

export const TodoStateContext = React.createContext<Todo[] | null>(null);
export const TodoDispatchContext = React.createContext<{
  onClickAdd: (text: string) => void;
  onClickDelete: (id: number) => void;
} | null>(null);

export function useTodoDispatch() {
  const dispatch = useContext(TodoDispatchContext);
  if (!dispatch) throw new Error("TodoDispatchContextì— ë¬¸ì œê°€ ìˆë‹¤");
  return dispatch;
}

function App() {
  const [todos, dispatch] = useReducer([]);
  const idRef = useRef(0); //React.MutableRefObject<number>

  const onClickAdd = (text: string) => {
    dispatch({
      type: "CREATE",
      data: {
        id: idRef.current++,
        content: text,
      },
    });
  };

  const onClickDelete = (id: number) => {
    dispatch({
      type: "DELETE",
      id: id,
    });
  };

  useEffect(() => {
    console.log(todos);
  }, [todos]);

  return (
    <div className="App">
      <h1>Todo</h1>
      <TodoStateContext.Provider value={todos}>
        <TodoDispatchContext.Provider
          value={{
            onClickAdd,
            onClickDelete,
          }}
        >
          <Editor />
          <div>
            {todos.map((todo) => (
              <TodoItem key={todo.id} {...todo} onClickDelete={onClickDelete} />
            ))}
          </div>
        </TodoDispatchContext.Provider>
      </TodoStateContext.Provider>
    </div>
  );
}

export default App;
```

```tsx
//components/Editor.tsx

import { ReactElement, useState } from "react";
import { TodoDispatchContext, useTodoDispatch } from "../App";

interface Props {}

export default function Editor(props: Props) {
  const [text, setText] = useState(""); //string type, ì œë„¤ë¦­ í•¨ìˆ˜
  const dispatch = useTodoDispatch();
  const onChangeInput = (e: React.ChangeEvent<HTMlInputElement>) => {
    setText(e.target.value);
  };

  const onClickButton = () => {
    dispatch.onClickAdd(text);
    setText("");
  };

  return (
    <div>
      <input value={text} onChange={onChangeInput} />
      <button onClick={onClickButton}>ì¶”ê°€</button>
    </div>
  );
}
```

```tsx
//components/TodoItem.tsx

import { Todo } from "../types";

//ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” íƒ€ì… ìœ ì§€í•´ì•¼í•  ë• ë³„ë„ì˜ tsx íŒŒì¼ ë§Œë“¤ê¸°
interface Props extends Todo {}

export default function TodoItem(props: Props) {
  const dispatch = useTodoDispatch();
  const onClickButton = () => {
    dispatch.onClickDelete(props.id);
  };

  return (
    <div>
      {props.id}ë²ˆ: {props.content}
      <button onClick={onClickButton}>ì‚­ì œ</button>
    </div>
  );
}
```

### ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©í•˜ê¸°

jsë¡œ ë§Œë“¤ì–´ì§„ ë¼ì´ë¸ŒëŸ¬ë¦¬ â†’ ex) npm i @types/lodash

### íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ í…œí”Œë¦¿ ì†Œê°œ

npx create-react-app . â€”template (ë‹¤ tsxë¡œ ë§Œë“¤ì–´ì§)
